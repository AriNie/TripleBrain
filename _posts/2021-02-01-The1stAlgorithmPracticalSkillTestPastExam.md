---
layout: post
title: 第一回 アルゴリズム実技検定 D問題 # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: ののの　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
本記事では第一回アルゴリズム実技検定D問題を解説していこうと思います。
# D問題　重複検査

<a href="https://atcoder.jp/contests/past201912-open/tasks/past201912_d">D - 重複検査</a>

---


> ## 問題文
> 長さ Nの整数列がサーバーに保管されている。つい先ほどまで、この列には1からNまでの整数が1個ずつ含まれていた。
> しかし、たった今発生したトラブルにより、列のいずれか1個の要素が別の1以上N以下の整数に書き換えられた可能性がある。
> あるいは、何の書き換えも発生しなかったかもしれない。
> トラブル発生後の整数列 A_1,…,A_Nが与えられる。これを読み込み、書き換えが発生していたかを判定し、
> 発生していた場合にはどの整数がどの整数に書き換えられたかを報告するプログラムを作成せよ。


> ## 制約
> * 1≦N≦200,000
> * 1≦A_i≦N
> * A_1,…,A_Nは問題文中の状況と矛盾しない。


> ## 入力
```
N
A_1
A_2
:
A_N
```



> ## 出力
> 書き換えが発生していなかった場合、Correct と出力せよ。
> 書き換えが発生していた場合、整数xが整数yに書き換えられたとして、yとxをこの順にスペース区切りで出力せよ。


## 方針

単純に解くだけなら、要素数がNで全ての要素が'False'の配列を用意してインプットした整数列の値に対応した要素を`True`に上書きなどしてフラグ管理をしてとすればよい。
このとき既にフラグが`True`に変更された要素をもう一度上書きしようとしているときその値がyとなるがxの値が分からない。よってもう一度配列を探索し残された`False`
を探さなければならない。書き換えがない場合は配列の要素がすべて`True`であることを確認しなければならないので`for`文を2度回さなければならない。
制約条件的に2度回してもいいがせっかくなので一度ですます方法を考えた。

書き換え前は整数列内に1からNが一回ずつ登場するのでその総和は`N(N+1)/2`である。上記と同様の方法でフラグ管理をしつつ、この値から入力されたAの値を引いていき、
すでにフラグの立った値の時はそれが書き換え後の値yなので記憶だけしておき、総和から引かないでおく。
その後全ての入力が終わったとき残った値が書き換え前の値xとなる。逆にyの値が保存されていなければ書き換えは行われなかったということになる。
またフラグ管理はTFではなく数値を引くことで管理した。

これを実行したのが下記のコードである。
```python
n=int(input())
#フラグ管理用
l=[1 for i in range(n)]
#1~Nの総和
s=n*(n+1)//2
#書き換え後の値保存用
y=-1
for i in range(n):
    a=int(input())
    l[a-1]-=1
    if l[a-1]==-1:
        y=a
    else:
        s-=a
#書き換え後の値が保存されている
if y!=-1:
    print(str(y)+' '+str(s))
#保存されていない（書き換えなし）
else:
    print('Correct')
```
