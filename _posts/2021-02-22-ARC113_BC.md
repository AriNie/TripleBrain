---
layout: post
title: AtCoder Regular Contest 113 B,C問題 # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: ののの　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
本記事ではAtCoder Regular Contest 058 C,D問題を解説していこうと思います。
# B問題 A^B^C

<a href="https://atcoder.jp/contests/arc113/tasks/arc113_b">B - A^B^C</a>

<br>

```
## 問題文

正の整数A,B,Cが与えられます。
A^(B^C)の 10進法での1の位を求めてください。
```

```
##制約
* 1≦A,B,C≦10^9
* A,B,Cは整数である
```

```
##入力
A B C
```

```
##出力
A^B^Cの10進法での1の位を出力せよ。
```

## 方針
$A^{B^C}≡ out {\pmod {10}}$とする。$out$は解答となる1の位。

$A^{B^C}$を考える前に$B^C=k$として$A^k$について考えたい。この時、$out$はAの1の位の値に依存する。

例えばA=17のとき、$k=1,2,3,4,5...$でのoutの値は$out= 7,9,3,1,7...$となる。続けるとわかるのだが値がループしている。他の値でやると分かるのだが、1ループあたりの数（A=17では7,9,3,1で4つ）は1 or 2 or 4である。このことから、$B^C$を4で割った余り$J$に着目すればいいことがわかる。

${B^C}≡J {\pmod {4}}$は0~3の整数を取るが0の時は注意が必要である。$A^0$はAの値によらず1となる。しかし、求めたいのはループの4番目の値である。よって、$J+4$をすることでこれを回避する必要がある。

これをコードで実装するには前回自分の解説でも用いた`pow(x,y,z)`を用いる。この関数の出力値は$x^y$をzで割った余りとなる。しかし、上記の通りあまり0は回避しなければならないので+4は必須である。よって、$k'=pow(b,c,4)+4$とすることができる。

このようにして$B^C$については$k'$で代用可能であることがわかったのであとは$A^{k'}$を10で割った余りについて考えればいいので$out=pow(a,k,10)$を求めるのみである。

コードは以下の通り
```python
a,b,c= list(map(int, input().split()))
k=pow(b,c,4)+4
o=pow(a,k,10)
print(o)
```
余談だがまとめるとコードは短縮可能。
```python
a,b,c= list(map(int, input().split()))
print(pow(a,pow(b,c,4)+4,10))
```


# C問題 String Invasion

<a href="https://atcoder.jp/contests/arc113/tasks/arc113_c">C - String Invasion</a>

<br>

```
## 問題文

長さN の文字列Sが与えられます。Sのi文字目をs_iで表します。以下の操作を繰り返せる回数の最大値を求めてください。
 *連続する3文字s_i,s_i+1,s_i+2(1≤i≤|S|−2)であって、s_i=s_(i+1)≠s_(i+2) si=si+1≠si+2 であるものを選ぶ。
  s_(i+2)をs_iで置き換える。
```

```
##制約
* 3≦|S|≦2*10^5
* Sは英小文字からなる
```

```
##入力
S
```

```
##出力
操作を繰り返せる最大値を出力せよ
```

## 方針
とりあえず方針としては文字列の右から順番確認でよさそう。

連続した文字がくるまで見ていき、連続した文字が来たとき前回の連続した文字が今回と同じか否かで別の処理を行う。

-連続した文字が同じとき(パターン1)-

この時は前回連続した文字までの文字数を操作回数の出力値$o$に加える。

-連続した文字が異なるとき(パターン2)-

この時は今回連続した文字より右に存在する文字数を操作回数の出力値$o$に加える。
こちらの場合、前回連続した文字よりも右の文字は前回連続した時と同じ文字が入っていると考えるからである。

その後文字が同じかにかかわらず以下の操作を行う。今回と前回連続した文字の間にある文字について調べていき、その中に今回連続した文字と同じ文字があるなら操作回数の出力値から1を引く。なぜこのような操作を行うかというと、例えば`rrcbrkoo`という文字列があるとき、`cb`を変更したとき、次の文字`r`に関しては今回連続したものと文字が同じであるからである。よって操作はできないので1を引く。

連続した文字と文字列が何番目に位置するかは配列`l`で管理した。

コードは以下の通り
```python
#input
s=list(input())
#文字列の長さ
n=len(s)
#初期値l=[[文字,位置]]
l=[[s[-1],n]]
#出力回数保存用
o=0
#for文で右から順にみていく
for i in range(n-2):
    #現在調べている2つの文字
    a=s[-(i+3)]
    b=s[-(i+2)]
    #文字列が同じとき
    if a==b:
        #連続した文字なので配列で管理
        l.append([s[-(i+3)],n-i-2])
        #前回と今回の文字が同じとき(パターン1)
        if l[0][0]==l[1][0]:
            o+=(l[0][1]-l[1][1]-1)
        #異なるとき(パターン2)
        else:
            o+=(i+1)
        #前回と今回連続した文字の間の文字を出力
        g = s[l[1][1]+1:l[0][1]]
        for j in g:
            if j==l[1][0]:
                o-=1    
        #前回連続した文字を削除
        l.pop(0)
print(o)
```
