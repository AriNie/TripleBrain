---
layout: post
title: AtCoder Regular Contest 058 C,D問題 # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: ののの　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
本記事ではAtCoder Regular Contest 058 C,D問題を解説していこうと思います。
# C問題 こだわり者いろはちゃん

<a href="https://atcoder.jp/contests/arc058/tasks/arc058_a">C - こだわり者いろはちゃん</a>

<br>

```
## 問題文

 いろはちゃんはこだわりもので、嫌いな数字がK個あり、それぞれD_1,D_2,...,D_K です。 
 いろはちゃんはお店でお買い物をしていて、 N円の品物を買おうとしています。 
 もちろん、この品物は N 円以上のお金を支払えば買うことができます。 
 しかし、先ほど述べたようにいろはちゃんは強いこだわりがあるので、自分がお店に支払う金額の
 10進表記にいろはちゃんの嫌いな数字が出現しないような最も少ない金額を支払おうとします。 
 いろはちゃんが支払う金額を求めてください。


```

```
##制約
* 1≦N≦10000
* 1≦K<10
* 0≦D_1<D_2<...<D_K≦9
* {D_1,D_2,...,D_K} ≠ {1,2,3,4,5,6,7,8,9}
```

```
##入力
N K
D_1 D_2 ... D_K
```

```
##出力
いろはちゃんが支払う金額を出力せよ
```

## 方針
　問題を要約するとN以上の{D_1,D_2,...,D_K}を用いないで作れる最小数を答える問題

　ここで注目したいのはNの範囲で10000程度しかないことから`while`文を使って答えとなりうる数値oを1から順番に調べていっても処理時間が足りそうである

　ここで考えたいのは自然数`o`の各桁をどうやって調べるかだが`o`を`int`型から`str`型に変換することで容易に解決することが可能である。文字列に対してリストと同様に[]とインデックス番号iを使うことでその文字列の左から`i+1`番目の文字を入手することができる。よって自然数`o`の左から3桁目の数値は`int(str(o)[3-1])`で表すことができる。（全体を`int`で括ってのは一度str型に変換しているため）

いろはちゃんの好みと数値がそもそもN以上かは関数`judge`を作り判定をした


コードは以下の通り
```python
#使用している数値の条件チェック
def judge(l,num,n):
    #現在の数値がN未満ならば細かいチェックは必要ない
    if num <n:
        return True
    else:
        #条件管理用
        tf = False
        #現在の数値の各桁がいろはちゃんの好みかを確認
        for i in range(len(str(num))):
            #嫌いな数字があるならば処理を終了
            if not int(str(num)[i]) in l:
                tf = True
                break
        return tf
#入力
n,k = list(map(int, input().split()))
d = list(map(int, input().split()))
#好みの数字を管理する配列
num_li=[i for i in range(10)]
#嫌いな数字を削除
for i in sorted(d, reverse=True):
    num_li.pop(i)
#出力用
o=0
#条件を満たす間は数値を1ずつ大きくする
while judge(num_li,o,n):
    o+=1
print(o)
```

# D問題 いろはちゃんとマス目

<a href="https://atcoder.jp/contests/arc058/tasks/arc058_b">D - いろはちゃんとマス目</a>

<br>

```
## 問題文

縦Hマス、横Wマスのマス目があります。
いろはちゃんは、今一番左上のマス目にいます。 
そして、右か下に1マス移動することを繰り返し、一番右下のマス目へと移動します。
ただし、下からA個以内、かつ左からB個以内のマス目へは移動することは出来ません。 
移動する方法は何通りあるか求めてください。 
なお、答えは非常に大きくなることがあるので、答えは 10^9+7で割ったあまりを出力してください。
```

```
##制約
* 1≦H,W≦100000
* 1≦A<H
* 1≦B<W
```

```
##入力
H W A B
```

```
##出力
移動する方法の数を10^9+7で割った余りを出力せよ。
```

## 方針
　いつも通り問題を要約すると、H×Wマスあり左上のマスから右下のマスまで移動方法のパターン数を知りたいが左下A×Bマスに入ることができないよとのことである。移動方法は右or下の2つなので面倒なことを考えなくてよい。
　解法としては<a href="https://img.atcoder.jp/data/arc/058/editorial.pdf">公式解説で紹介されてるイメージ</a>のように通ることができるパターン数を考える。パターン数は高校数学で習ったような$$(x+y)!/(x!y!)=_{x+y}C_{x}$$を使えばよい。


しかし、ここで厄介なのが答えを`10^9+7`で割ったあまりで出力しなければならないことである。積だけならば問題ないがパターン数計算のために割り算をしなければならないことが問題を複雑化している。

今回はその計算方法をメインに解説したいと思う。

コンビネーション計算のために割り算をしつつ所謂Modの計算を効率よくする方法として本解法では<a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A7%E3%83%AB%E3%83%9E%E3%83%BC%E3%81%AE%E5%B0%8F%E5%AE%9A%E7%90%86">フェルマーの小定理</a>を使うことになる。これは10^9+7が素数なことを利用している。

フェルマーの小定理は以下の式である。
$${\displaystyle a^{p-1}\equiv 1{\pmod {p}}}$$
ここでa,pは互いの素であり、この式はaのp-1乗をpで割った余りは1であることを示している。

次にこれをコンビネーション計算に応用するために逆元について説明する。$p$を素数、$b$を$p$で割り切れない整数としたとき$$bx≡1{\pmod {p}}$$を満たす$x$が一意に存在することである。これを$x$が$p$の逆元であるという。

フェルマーの小定理に逆元を適用すると
$${\displaystyle b×b^{p-2}\equiv 1{\pmod {p}}}$$であることから$b^{p-2}$が$b$の逆元であることがわかる。


$a÷b≡a×(1÷b){\pmod {p}}$であることから$1÷b$を$p$で割った余りについてのみ考えればいいことは明らかである。

また、先の$bx≡1{\pmod {p}}$を変形すると$x≡1÷b{\pmod {p}}$となる。

これをフェルマーの小定理の逆元式に適用すると
$${\displaystyle b^{p-2}\equiv 1÷b{\pmod {p}}}$$
と表すことができることから割る値は$b^{p-2}{\pmod {p}}$で管理可能である。また、これは`pyhon`において組み込み関数`pow(b,p-2,p)`で表現可能である

ここからようやく解法に移ることができる。
まず、階乗の値は何回か利用するので最初にmodを使いつつリストで計算する必要がある。リストの幅はマス目がH*Wであることから0~H+W+1までの計算で充分である。逆元も同様で0~H+W+1で十分足りる。
コンビネーションの計算式は以下のようになる。
$$(x+y)!/(x!y!)≡(x+y)!×x!^{p-2}×y!^{p-2} {\pmod {p}}$$





コードは以下の通り
```python
#コンビネーション
def c(n, r,m):
    return f[n] * inverse[r] * inverse[n-r] % m

h,w,a,b = list(map(int, input().split()))
mod = pow(10,9)+7
#階乗管理用
f = [1] * (h+w+1)
#逆元管理用
inverse = [1] * (h+w+1)
#階乗計算用
k = 1
for i in range(1, h+w+1):
    #階乗更新
    k = (k * i) % mod
    #階乗保存
    f[i] = k
    #逆元保存
    inverse[i] = pow(f[i], mod-2, mod)
#出力
o = 0
#ルート数の計算
for i in range(b, w):
    o += c(h-a-1+i, i,mod) * c(a-1+w-i-1, a-1,mod) % mod
    o %= mod
 
print(o)
```

##参考にさせていただいたサイト
<a href="https://drken1215.hatenablog.com/entry/2018/06/08/210000">https://drken1215.hatenablog.com/entry/2018/06/08/210000</a>
