---
layout: post
title: AtCoder Beginner Contest 191 C問題・D問題を解く # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: れぇなん　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
# C問題 Digital Graffiti

<a href="https://atcoder.jp/contests/abc191/tasks/abc191_c" target="_blank">C - Digital Graffiti</a>

> ## 問題文
>H
  行 
W
 列のマス目があります。このマス目の、上から 
i
 番目、左から 
j
 番目のマスを、マス 
(
i
,
j
)
 と呼ぶことにします。
>
>各マスは黒または白に塗られています。
S
i
,
j
 が # ならばマス 
(
i
,
j
)
 は黒に塗られており、. ならば白に塗られています。
>
>マス目の一番外側のマス、すなわち 
(
1
,
j
)
,
(
H
,
j
)
,
(
i
,
1
)
,
(
i
,
W
)
 のいずれかの形で表されるマスは白に塗られていることが保証されます。
>
>黒に塗られた部分を多角形として見たとき、これが (最小で) 何角形になるかを求めてください。
>
>ここで、黒に塗られた部分は一つの自己交叉のない多角形となることが保証されます。すなわち、以下のことが保証されます。
>
> * 黒に塗られたマスが少なくとも一つ存在する
>
> * 黒に塗られた任意の 
2
 マスは、辺を共有するマスへの移動を繰り返し、黒に塗られたマスのみを通って互いに到達可能である
>
> * 白に塗られた任意の 
2
 マスは、辺を共有するマスへの移動を繰り返し、白に塗られたマスのみを通って互いに到達可能である(マス目の一番外側のマスは全て白に塗られていることに注意してください)

> ## 制約
> * 3
≤
H
≤
10
>
> * 3
≤
W
≤
10
>
> * S
i
,
j
 は # または .
>
> * S
1
,
j
,
S
H
,
j
 は .
>
> * S
i
,
1
,
S
i
,
W
 は .
>
> * 黒に塗られた部分は一つの自己交叉のない多角形となる

<br>

## 方針
入力された図形が何角形かを知るためにはその図形の頂点の数を数える必要がある。
<br>
今回の問題においてある点(x,y)が頂点かどうかを知るためには、その点の周囲4マス(S_x_y,S_x-1_y,S_x_y-1,S_x-1_y-1)において`#`が何個あるのかを確認すればよい。
<br>
マス目の一番外側のマス、すなわち 
(
1
,
j
)
,
(
H
,
j
)
,
(
i
,
1
)
,
(
i
,
W
)
 のいずれかの形で表されるマスは白に塗られていることが保証されているため、`#`が１個または３個の時に(x,y)が頂点であるということが言える。
<br>
また、今回は自己交叉のない多角形であることが保証されているため、`#`が２個の場合に頂点である場合を考えなくてよい。
<br>
これらのことから、入力されたマス目ひとつひとつに対して頂点か否かを判定していき、その頂点の数から何角形かを答えればよいことがわかる。

<br>

## コード(Python)

```python
H,W=map(int,input().split())
S=[input() for _ in range(H)]
 
cnt=0
 
for i in range(1,H):
    for j in range(1,W):
        tmp=0
        if S[i-1][j-1]=="#":
            tmp+=1
        if S[i-1][j]=="#":
            tmp+=1
        if S[i][j-1]=="#":
            tmp+=1
        if S[i][j]=="#":
            tmp+=1
        if tmp==1 or tmp==3:
            cnt+=1
print(cnt)
```
---

# D問題 Circle Lattice Points

<a href="https://atcoder.jp/contests/abc191/tasks/abc191_d" target="_blank">D - Circle Lattice Points</a>

> ## 問題文
>
>2
 次元平面上に中心 
(
X
,
Y
)
 、半径 
R
 の円があります。
>
>この円の内部または周上にある格子点 (
x
,
y
 座標がともに整数である点) の個数を求めてください。

> ## 制約
> * |
>X
|
≤
10^5
>
> * |
Y
|
≤
10^5
>
> * 0
<
R
≤
10^5
>
> * X
,
Y
,
R
 は高々小数第 
4
 位まで与えられる

<br>

## 方針
まず、単純に格子点の個数を数える方法を考える。
<br>
格子点のx座標の範囲を計算し、それぞれのx座標においての格子点の数を求めて足し合わせれば簡単に数えられそうだ。
<br>
円の格子点の数の求め方は調べればいくらでもでてくるので、今のでわからなかったら自分で調べてみてほしい(投げやり)。
<br>
格子点の数の求め方はわかったが、今回注意すべきである点は２つある。
<br>
1. 中心座標と半径が小数となるため、単純なx座標の範囲と格子点のx座標の範囲が異なる
2. 浮動小数点数の計算をする場合、小数点数を計算するときや丸めるときに誤差が発生する場合がある
<br>

1に関しては天井関数と床関数を用いればいいだけである。
<br>
2に関しては対処法は様々であるが、今回はDecimalモジュールを用いた。
<br>
Decimalモジュールとは、有効桁数の表記を取り入れることにより10進数である浮動小数点数の計算を厳密に行えるモジュールである。(<a href="https://docs.python.org/ja/3/library/decimal.html" target="_blank">ドキュメントを参照</a>)
<br>
以上のことを踏まえてプログラムを書けばよさそうだ。

## コード(Python)
```python
from math import ceil, floor
from decimal import Decimal

X, Y, R = map(Decimal, input().split())
 
#格子点のx座標の範囲を計算
top = floor(X+R)
bottom = ceil(X-R)
acu = 0

#それぞれのx座標における格子点の数を計算
for r in range(bottom, top+1):
    d = Decimal(R**2 - (X-r)**2).sqrt()
    d_top = floor(Y+d)
    d_bottom = ceil(Y-d)
    acu += d_top-d_bottom+1
 
print(acu)
```
