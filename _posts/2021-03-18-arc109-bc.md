---
layout: post
title: AtCoder Regular Contest 109 B,C問題を解く # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: れぇなん　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
# B問題 log

<a href="https://atcoder.jp/contests/arc109/tasks/arc109_b" target="_blank">B - log</a>

> ## 問題文
>すぬけ君は、渋谷の丸太やさんに丸太を買いに来ました。 すぬけ君は長さ 
1
 から 
n
 までの 
n
 種類の丸太が 
1
 本ずつほしいです。 
> 
>丸太やさんには、長さ 
1
 から 
n+
1
 までの 
n+
1
 種類の丸太がそれぞれ 
1
 円で売られています。
>
>どの丸太の在庫も 
1
 本ずつしかありません。
>
>すぬけ君は買った丸太を切る作業を好きなだけ行えます。つまり、
L
=
L
1+⋯+
L
k
 であるとき、長さ 
L
 の丸太 
1
 本から、長さ 
L
1
,
…
,
L
k
 の 
k
 本の丸太を作る作業を何度でもできます。また、不要な丸太を捨てることができます。
>
>すぬけ君はできるだけ安く丸太を手に入れたいです。 長さ 
1
 から 
n
 までの 
n
 種類の丸太を 
1
 本ずつ手に入れるために必要な最小の金額を求めてください。

> ## 制約
> * 1
≤
n
≤
10^18

<br>

## 方針
長さが1からnまでの丸太が欲しい状態で、長さが1からn+1までの丸太を１本ずつ買うことが出来る。長さn+1の丸太が余っているので、この丸太でどれくらいの数の丸太を作ることが出来るのかを考えたい。
<br>
購入する丸太の本数は少ないほど良いので、長さn+1の丸太で出来る限りたくさんの丸太を作りたい。それぞれの長さの丸太は1本あれば良いので、長さが短い丸太から順に作っていき、長さがいくつの丸太まで作れるかが分かれば最小の本数がわかる。
<br>
これは1+2+...k<=n+1を満たす最大のkを求めればよい。n+1を超すか超さないかのラインを知りたいときは二分探索が計算効率よさそうなので使いたい。

<br>

## コード(Python)

```python
n = int(input())
low = 1
high = 10**18
mid = 0
#二分探索
while high - low > 1:
  mid = (high + low)//2
  #1+2+...+k<=n+1かどうかの判定
  if mid*(mid+1)//2 <= n+1:
    low = mid
  else:
    high = mid

print(n-low+1)
```
---

# C問題 Large RPS Tournament

<a href="https://atcoder.jp/contests/arc109/tasks/arc109_c" target="_blank">C - Large RPS Tournament</a>

> ## 問題文
>
>最強のじゃんけんの手を決めるため、トーナメント形式のじゃんけん大会が開催されます。 大会の参加者は 
2^k
 人で、それぞれ 
0
 以上 
2^k
 未満の整数が振られています。どの参加者もそれぞれ得意な手を持っていて、毎試合得意な手のみを出します。
>
>参加者の得意な手は、長さ 
n
 の R, P, S からなる文字列 
s
 によって表されます。 具体的には、番号 
i
 の参加者の得意な手は 
s
 の 
(
i
 mod 
n
)+
1
 文字目の文字で表されます。ここで、R はグー、P はパー、S はチョキを表します。
>
>r−
l
 が 
2
 のべき乗であるような 
l
,
r
 について、番号が 
l
 以上 
r
 未満の参加者による大会を開いたとき、勝者は次のようにして決定されます。
>
> * r−
l
=
1
 であるとき（つまり、参加者がただ一人であるとき）、勝者は 
l
 とする。
>
> * r−
l
≥
2
 であるとき、
m
=
(
l+
r
)
/
2
 として、
l
 以上 
m
 未満の参加者による大会と、
m
 以上 
r
 未満の参加者による大会を開催する。それぞれの勝者が 
a
,
b
 であるとき、
a
 と 
b
 がじゃんけんをして勝ったほうを勝者とする。あいこの場合 
a
 を勝者とする。
番号が 
0
 以上 
2^k
 未満の参加者による大会の勝者の得意な手を求めてください。

> ##  注意
> * a
 mod 
b
 は 
a
 を 
b
 で割ったあまりを表す
>
> * じゃんけんの勝敗は次のように決められる
>> * 同じ手同士はあいこである
>> * R は S に勝つ
>> * P は R に勝つ
>> * S は P に勝つ

> ## 制約
> * 1
≤
n
,
k
≤
100
>
> * s
 は R, P, S のみからなる長さ 
n
 の文字列

<br>

## 方針
制約がめっちゃ優しいので、特にアルゴリズム等で工夫する必要はなく、ただただ正確な答えが出るように実装すればよい。
<br>
この問題では、隣同士の人がひたすらじゃんけん勝負をし、最後の一人になるまで続けるだけなので、隣同士の文字を比較し、勝った方をリスト等で残していくプログラムを作っていきたい。
<br>
参加人数が奇数であった場合の処理がめんどくさい、文字列sを循環させたい等の理由から、今回は隣同士の文字を比較し、勝った方を残した後に、毎回文字列を２倍にする処理をしている。
<br>
そうすることにより、簡単なfor文のみでの実装が可能になる。
<br>
リストの中で参加者全員分の戦いが網羅できていないように見えるが、for文を繰り返していくうちに網羅できていないように見えた勝者たちもリストの中に入ってくるので、最終的な勝者はわかる。(分かりにくいかもしれないが、『視野が狭いためトーナメント表の一部しか観れていない状態だが、戦いを繰り返しているうちに参加者が減っていき、全容がわかる』といったイメージ??????)
<br>
文字列の長さ自体はいつまでも変わらないが、最後まで繰り返していくと、最終的な勝者がリストの一番左に来るので、その部分を答えとして出力すればよい。

## コード(Python)
```python
n,k = map(int,input().split())
s = input()
curs = []
for i in range(n):
    curs.append(s[i])
 
for i in range(k):
    curs = curs * 2
    nexs = []
    for j in range(0,2*n,2):
        if (curs[j] == "S" and curs[j+1] == "R") or (curs[j] == "P" and curs[j+1] == "S") or (curs[j] == "R" and curs[j+1] == "P"):
            nexs.append(curs[j+1])
        else:
            nexs.append(curs[j])
            
    curs = nexs
    
print(curs[0])
```
