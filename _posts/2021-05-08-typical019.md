---
layout: post
title: 競プロ典型90問 008 # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: ののの　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
本記事では競プロ典型 90 問の019 - Pick Twoを解説していこうと思います。
# 019 - Pick Two

<a href="https://atcoder.jp/contests/typical90/tasks/typical90_s">019 - Pick Two</a>

<br>


## 問題文
>長さ $2N$ の正整数列$A=(A_1,A_2,…,A_{2N})$ が与えられます。 次の操作で列$A$から数を取り除くことを考えます。 残っている列を $(A'_1,A'_2,…,A'_M)$とする。 $1 ≤ i < M$ を満たす整数 $i$を一つ選び、 $A'_i$ と$A'_{i+1}$ を列から取り除く。この操作のあと、残る列は$(A'_1,…,A'_{i−1},A'_{i+2},…,A'_M)$ である。 この操作には コスト がかかります。 1回の操作にかかるコストは、取り除く数を$A'_i,A'_{i+1}$ として$|A'_i−A'_{i+1}|$ です。 この操作を$N$回繰り返して列$A$ から全ての数を取り除くとき、$N$ 回の操作にかかるコストの総和として考えられる最小の値を求めてください。


## 制約
> * $1≤N≤200$
>* $1≤A_i≤10^6$  $(1≤i≤2N)$
>* 入力は全て整数




## 入力

> $N$
>
> $A_1, A_2,...,A_{2N}$



## 出力
>$N$回の操作にかかるコストの総和として考えられる最小の値を出力してください。

## 方針
区間DPで解くのがよさそう


$$dp[l][r]=(部分区間[l,r]に存在する数値の除去に必要なコスト)$$
とする

すると更新式は

$$dp[l]][r] = \left\{\begin{array}{ll}dp[l+1][r-1]+|A_l-A_r| & (既に部分区間の中が除去されてるパターン)\\dp[l]][k]+dp[k+1][r] & (部分区間をさらに2分割するパターン) \\|A_l-A_r| & (r-l=1)\end{array}\right.$$
ただし$k=l+1,l+3,...r-3,r-1$となる

更新式が分かったところでコードの説明をしたい。本来ならば配列をうまく使うべきだと思うがせっかくなので最近知ったfunctoolsのlru_cacheを使いたい。

細かいことは各自で調べてくれるとありがたい

この子のすごさは関数にデコレータを付けることで発揮される。ある引数に対する計算結果を保存しておき、もう一度同じ引数でこの関数を呼ぶと前回の結果を参照してその値を返すことである。

コードは以下の通り
```python
from functools import lru_cache
@lru_cache(maxsize=None)
def dp(l,r):
    if r-l ==1:
        #r-l=1
        return abs(a[l]-a[r])
    #既に部分区間の中が除去されてるパターン
    re=dp(l+1,r-1)+abs(a[l]-a[r])
    #部分区間をさらに2分割するパターン
    for k in range(l+1,r,2):
        re=min(re,dp(l,k)+dp(k+1,r))
    return re

#入力
n=int(input())
a=list(map(int,input().split()))
print(dp(0,2*n-1))
```

