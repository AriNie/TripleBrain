---
layout: post
title: 第一回 アルゴリズム実技検定 E問題 # ページタイトル
tags: atcoder algorithm python # タグ
categories: atcoder # カテゴリ. AtCoderの解説記事は atcoder で.
---


* TOC
{:toc}

Author: ののの　<!-- 自分の名前 -->

<!-- ↓↓↓↓↓ 記事内容 ↓↓↓↓↓ -->
本記事では第一回アルゴリズム実技検定E問題を解説していこうと思います。
# E問題　SNS のログ

<a href="https://atcoder.jp/contests/past201912-open/tasks/past201912_e">E - SNS のログ</a>

<br>

```
## 問題文
あなたは、N人のユーザが参加する SNS を運営している。彼らはユーザ1,…,Nと呼ばれ、別のユーザを何人でもフォローすることができる。
しかし、あるトラブルにより、どのユーザがどのユーザをフォローしているかの情報がすべて失われてしまった。

幸い、ユーザがこのSNS で行ったすべての操作のログが残っており、あなたは操作ログをもとにフォロー状況を復元しようとしている。
操作ログは Q行からなり、その i行目 (1≦i≦Q)は文字列Siである。各ユーザは以下の3種類の操作を行うことができ、
S_iはSNS全体でi番目に行われた操作に対応する。
* フォロー: ユーザaがユーザb(a≠b)をフォローする。ログには 1 a b という行が記載される。
* フォロー全返し: ユーザaが、その時点でユーザ aをフォローしているユーザ全員をフォローする。ログには 2 a という行が記載される。
* フォローフォロー: その時点でユーザaがフォローしている各ユーザxに対し、
  ユーザaが次を行う: 「その時点でユーザ xがフォローしているすべてのユーザ (ユーザ a自身を除く) をフォローする」。
  ログには 3 a という行が記載される。なお、この SNS が開設された時点では、どのユーザも誰もフォローしていなかった。
  また、ユーザ aがユーザ bを既にフォローしているとき、ユーザaがユーザbを再びフォローしても何も起こらない。
フォロー状況を復元せよ。
```

```
##制約
* 2≦N≦100
* 1≦Q≦N
* S_iは以下のいずれかの形式の文字列である。
    *1 a b (1≦a,b≦Nかつ a≠b)
    *2 a (1≦a≦N)
    *3 a (1≦a≦N)
```

```
##入力
Q
S_1
S_2
:
S_N
```

```
##出力
各 i,j (1≤i,j≤N)に対し、ユーザiがユーザ jをフォローしているときf_(i,j)=Y, そうでないときf_(i,j)=N として、以下の形式で出力せよ。
f_(1,1)f_(1,2)・・・f_(1,N)
f_(2,1)f_(2,2)・・・f_(2,N)
：
f_(N,1)f_(N,2)・・・f_(N,N)

```

## 方針
すごく長い問題文ですが要約するとSNSのフォロー関係を調べたいらしい。
フォロー関係は出力が文字列となっているが管理するのが大変なので配列で管理したい(index番号が0からなので1ずれることに注意)。この時、ユーザiがユーザjをフォローしているかの情報は配列の(i-1,j-1)要素に記憶されている。

コマンドは全部で3種類。
 * 単純なフォロー（follow）
 * フォロバ(follow_back)
 * 自分がフォローしてる人全員のフォロー先をフォローする(follow_follow)

2,3個目のコマンドはコードがある程度長くなりそうなのでコマンドごとの関数を予め作りたい。

1つ目のコマンドに関しては特に語ることはないので割愛。

2つ目のコマンドに関して、フォロー返しはユーザaをフォローをしているならこちらもフォローを返そうということなのでaをフォローしている人の情報が必要である。配列の(i-1,a-1)がYならば配列のユーザaもユーザiをフォローしなければならない。つまり配列の(a-1,i-1)もYにしなければならない。これは1つのfor文でやってよい。

3つ目のコマンドに関して、これはまずユーザaのフォロー情報を全て別の配列に記憶する必要がある。なぜなら、その後にそのフォロー先の情報を見てさらにフォローするので途中で自分のフォロー情報が書き換わってしまうからである。もう一つ注意しなければならないのは自分と相手が相互フォローの関係にあるとき自分をフォローしてしまうので予めif文で回避しなければならない

コマンドは以下の通り
```python
def follow(li,ui,uj):
    li[ui][uj]='Y'
    return li

def follow_back(n,li,ui):
    
    for fbi in range(n):
        #自分がフォローされているか確認
        if li[fbi][ui]=='Y':
            #フォローされているならばフォローを返す
            li[ui][fbi]='Y'
    return li

def follow_follow(n,li,ui):
    fo_fo=[]
    fo=[]
    #自分のフォロー先記憶
    for f in range(n):
        if li[ui][f]=='Y':
            fo_fo.append(f)
    #フォロー先のフォロー情報を記憶
    for f in fo_fo:
        for in_i in range(n):
            if li[f][in_i]=='Y' and in_i != ui:
                fo.append(in_i)
    #自分のフォローに反映
    for f in fo:
        li[ui][f]='Y'
    return li
#入力
n,q=list(map(int, input().split()))
#初期配列（フォロー関係なし）
l=[['N' for i in range(n)] for j in range(n)]

for i in range(q):
    #入力を分割
    abc=input().split()
    入力の第一要素の値に合わせて分岐
    if abc[0]=='1':
        l=follow(l,int(abc[1])-1,int(abc[2])-1)
    elif abc[0]=='2':
        l=follow_back(n,l,int(abc[1])-1)
    else:
        l=follow_follow(n,l,int(abc[1])-1)
#配列を出力に変換
for i in range(n):
    st=''
    for j in range(n):
        st+=l[i][j]
    print(st)

```
